"""Script used to evaluate the accuracy of the geocorrect module.

The EMIT datasets distributed via NASA CMR consist of products that have both
raw observations and a Geographic Lookup Table (GLT) that provides the mapping
from array indices to their position in a north-up lat-lon grid. Those GLTs were
used to evaluate the geocorrect module written to generate GLTs for datasets
that only have raw observations.

Usage:
  geocorrect_eval <input> <output1> <output2>

Arguments:
  input: The local path to a .nc file from the EMIT L2A RFL dataset. Go to
    https://search.earthdata.nasa.gov/search/granules?p=C2408750690-LPCLOUD and
      pick a product to download, selecting a file with prefix "EMIT_L2A_RFL"
      (e.g. EMIT_L2A_RFL_001_20250101T005312_2500101_002.nc).
  output1: The local path for one of the outputs, a .tif file containing the
    Haversine distance from each projected point to its source using the GLT in
    the .nc file.
  output2: The local path for the second output, a .tif file containing the
    Haversine distance from each projected point to its source using the GLT
    generated by the geocorrect module.

The Haversine formula (https://en.wikipedia.org/wiki/Haversine_formula) is used
to determine the great circle distance between two points on a sphere. Even
though the Earth is not perfectly round, it provides a good tradeoff between
accuracy and speed.

The two output .tif files can then be ingested into Earth Engine to visualize
the similarities and differences, using a Code Editor script like:

  function load_haversine(asset) {
    var hav = ee.Image(asset);
    var hav_vis = {min:0, max:100000, palette:['white', 'red']};
    Map.centerObject(hav);
    Map.addLayer(hav, hav_vis, asset);
    print(asset);
    print(ui.Chart.image.histogram({image: hav, maxBuckets: 16}));
    return hav;
  }

  var src_hav = load_haversine('projects/YOUR_PROJECT/assets/OUTPUT1_ASSET');
  var our_hav = load_haversine('projects/YOUR_PROJECT/assets/OUTPUT2_ASSET');

  print('haversine difference (histo)');
  var diff_hav = src_hav.subtract(our_hav);
  Map.addLayer(
    diff_hav,
    {min:-100, max:100, palette:['red', 'white', 'green']},
    'haversine difference');
  print(ui.Chart.image.histogram({image: diff_hav, maxBuckets: 32}));

  print('haversine difference (absolute)');
  var total_diff = diff_hav.reduceRegion(ee.Reducer.sum());
  print(total_diff.get('b1'));

With this script, when the diff is positive it means that the geocorrect module
is closer.
"""

from collections.abc import Sequence

from absl import app
import h5py
import numpy
from osgeo import gdal
from osgeo import gdal_array

from google3.third_party.earthengine_catalog.pipelines import geocorrect


def save_array_to_tif(
    tif_path: str,
    numpy_array: numpy.ndarray,
    gt: Sequence[float],
) -> None:
  """Saves `numpy_array` to `tif_path`."""
  options = ['COMPRESS=DEFLATE', 'ZLEVEL=9', 'BIGTIFF=YES']
  dtype = numpy_array.dtype
  if dtype == numpy.dtype(numpy.int8):
    options.append('PIXELTYPE=SIGNEDBYTE')
  if numpy.issubdtype(dtype, numpy.integer):
    options.append('PREDICTOR=2')
  elif numpy.issubdtype(dtype, numpy.floating):
    options.append('PREDICTOR=3')

  driver = gdal.GetDriverByName('GTiff')
  output_tif = driver.CreateCopy(
      tif_path,
      gdal_array.OpenArray(numpy_array),
      0,  # Copy may be not strict
      options,
  )
  output_tif.SetGeoTransform(gt)
  output_tif.SetProjection('EPSG:4326')
  output_tif.Close()


def generate_haversine_tif(
    tif_path: str,
    source_lat: numpy.ndarray,
    source_lon: numpy.ndarray,
    glt: numpy.ndarray,
    gt: Sequence[float],
) -> None:
  """Writes a tif with the Haversine distances to each pixel's source point."""
  # Calculate lat/lon center of each pixel in the bounding box.
  lat = numpy.array([
      [gt[3] + (x * gt[5]) + (gt[5] / 2)] * glt.shape[1]
      for x in range(0, glt.shape[0])
  ])
  lon = numpy.array([
      [gt[0] + (y * gt[1]) + (gt[1] / 2) for y in range(0, glt.shape[0])]
      for _ in range(0, glt.shape[1])
  ])
  lon = numpy.rot90(numpy.rot90(numpy.rot90(lon)))

  # Sometimes lat and lon come out as 3D arrays with a 3rd dimension of size 1.
  if len(lat.shape) > 2:
    lat = lat[:, :, 0]
  if len(lon.shape) > 2:
    lon = lon[:, :, 0]

  # Determine the source lat/lon center of each projected pixel using the GLT.
  valid_glt = numpy.all(glt != -1, axis=-1)
  proj_lat = lat.copy()
  proj_lat[valid_glt] = source_lat[glt[valid_glt, 0], glt[valid_glt, 1]]
  proj_lon = lon.copy()
  proj_lon[valid_glt] = source_lon[glt[valid_glt, 0], glt[valid_glt, 1]]

  def haversine_distance(coords: numpy.ndarray) -> float:
    """Calculates the haversine distance between two points in meters."""
    rads = numpy.radians(coords)
    hav = max(
        geocorrect.pairwise.haversine_distances([rads[0:2], rads[2:4]])[0]
    )
    # Earth mean radius in meters.
    return 6378137 * hav

  hav = numpy.reshape(
      numpy.apply_along_axis(
          haversine_distance,
          -1,
          numpy.stack(
              (
                  # Each input to the method defined above is a length-4 array
                  # containing (lat1, lon1) and (lat2, lon2) in that order.
                  lat.flatten(),
                  lon.flatten(),
                  proj_lat.flatten(),
                  proj_lon.flatten(),
              ),
              axis=-1,
          ),
      ),
      shape=lat.shape,
  )

  # Filter out the distances of unprojected pixels before writing the tif.
  invalid_glt = numpy.all(glt == -1, axis=-1)
  hav[invalid_glt] = numpy.nan
  save_array_to_tif(tif_path, hav, gt)

  # Print some stats for additional analysis.
  valid_hav = hav[valid_glt]
  print(tif_path)
  print('Mean:', numpy.mean(valid_hav), ', Median:', numpy.median(valid_hav))
  print(
      'Percentile (50, 90, 95, 99):',
      numpy.percentile(valid_hav, (50, 90, 95, 99)),
  )
  print('Histogram:', numpy.histogram(valid_hav, bins=16))


def main(argv: Sequence[str]) -> None:
  if len(argv) != 4:
    raise app.UsageError(
        'Expected usage: geocorrect_eval <input> <output1> <output2>'
    )
  _, infile, outfile1, outfile2 = argv

  # Read the raw lat and lon points from the source file as well as the GLT.
  # The GLTs come 1-indexed, so we adjust them to be 0-indexed like ours.
  rfl_file = h5py.File(infile, 'r')
  lat = rfl_file['location']['lat']
  lon = rfl_file['location']['lon']
  src_glt_x = rfl_file['location']['glt_x'][:].copy() - 1
  src_glt_y = rfl_file['location']['glt_y'][:].copy() - 1
  scale = rfl_file.attrs.get('spatialResolution')

  # Generate our GLT. If the input file happens to cross the antimeridian, we
  # only look at one hemisphere.
  index = geocorrect.CoordinateIndex.from_arrays(
      lat, lon, lat_fill_value=lat.fillvalue, lon_fill_value=lon.fillvalue
  )
  glt = geocorrect.GeoLookupTable.from_index(
      index,
      scale_lat=-scale,
      scale_lon=scale,
      num_threads=6,
  )[0]

  generate_haversine_tif(
      outfile1,
      lat[:],  # Note that these must be converted to vanilla numpy arrays.
      lon[:],
      numpy.stack((src_glt_y, src_glt_x), axis=-1),
      rfl_file.attrs.get('geotransform'),
  )
  generate_haversine_tif(
      outfile2,
      lat[:],  # Note that these must be converted to vanilla numpy arrays.
      lon[:],
      glt._glt,
      glt.geotransform(),
  )


if __name__ == '__main__':
  app.run(main)
